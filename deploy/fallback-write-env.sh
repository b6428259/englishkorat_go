#!/usr/bin/env bash
set -euo pipefail

# fallback-write-env.sh
# Purpose: Generate a production-ready .env on the target host without AWS SSM
#          using environment variables passed from the CI (GitHub Actions).
#
# It prefers explicit DB_*, REDIS_*, AWS_*, S3_*, JWT_* env vars if present,
# and otherwise falls back to PROD_* variants (e.g., PROD_DB_HOST -> DB_HOST).
# If essential DB settings are missing, it exits with an error.

log() { printf "[%s] %s\n" "fallback-env" "$*" >&2; }

# Helper to pick first non-empty value among args
pick() {
	for v in "$@"; do
		if [ -n "${v:-}" ]; then
			printf '%s' "$v"
			return 0
		fi
	done
	return 1
}

# Support dynamic STAGE-based prefix mapping. For STAGE=uat we will also attempt UAT_DB_HOST, etc.
STAGE_UPPER=$(echo "${STAGE:-}" | tr '[:lower:]' '[:upper:]')

# Helper to read a var considering stage + PROD fallback + base
stage_pick() {
	local base="$1"; shift || true
	local val=""
	# 1. explicit var (e.g., DB_HOST)
	val=${!base:-}
	if [ -n "$val" ]; then printf '%s' "$val"; return 0; fi
	# 2. stage-specific (e.g., UAT_DB_HOST)
	if [ -n "$STAGE_UPPER" ]; then
		local stageVar="${STAGE_UPPER}_${base}"
		val=${!stageVar:-}
		if [ -n "$val" ]; then printf '%s' "$val"; return 0; fi
	fi
	# 3. PROD_ fallback (historical naming)
	local prodVar="PROD_${base}"
	val=${!prodVar:-}
	if [ -n "$val" ]; then printf '%s' "$val"; return 0; fi
	return 1
}

DB_HOST=$(stage_pick DB_HOST) || true
DB_PORT=$(stage_pick DB_PORT) || true
DB_USER=$(stage_pick DB_USER) || true
DB_PASSWORD=$(stage_pick DB_PASSWORD) || true
DB_NAME=$(stage_pick DB_NAME) || true

# Defaults (tuned to repo conventions and compose setup)
DB_PORT=${DB_PORT:-3307}

# Redis: we generally use the compose service name inside docker network
REDIS_HOST=$(stage_pick REDIS_HOST) || true
REDIS_PORT=$(stage_pick REDIS_PORT) || true
REDIS_PASSWORD=$(stage_pick REDIS_PASSWORD) || true
REDIS_HOST=${REDIS_HOST:-redis}
REDIS_PORT=${REDIS_PORT:-6379}
REDIS_PASSWORD=${REDIS_PASSWORD:-adminEKLS1234}

# JWT and AWS/S3
JWT_SECRET=${JWT_SECRET:-$(stage_pick JWT_SECRET || true)}
JWT_EXPIRES_IN=${JWT_EXPIRES_IN:-7d}
AWS_REGION=${AWS_REGION:-ap-southeast-1}
AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID:-$(stage_pick AWS_ACCESS_KEY_ID || true)}
AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY:-$(stage_pick AWS_SECRET_ACCESS_KEY || true)}
S3_BUCKET_NAME=${S3_BUCKET_NAME:-$(stage_pick S3_BUCKET_NAME || true)}

# LINE Notify/Channel (optional)
LINE_CHANNEL_SECRET=${LINE_CHANNEL_SECRET:-$(stage_pick LINE_CHANNEL_SECRET || true)}
LINE_CHANNEL_ACCESS_TOKEN=${LINE_CHANNEL_ACCESS_TOKEN:-$(stage_pick LINE_CHANNEL_ACCESS_TOKEN || true)}

# phpMyAdmin convenience (optional). If not provided, derive from DB settings
PMA_HOST=${PMA_HOST:-${DB_HOST:-}}
PMA_USER=${PMA_USER:-${DB_USER:-}}
PMA_PASSWORD=${PMA_PASSWORD:-${DB_PASSWORD:-}}

# App/server defaults
APP_ENV=${APP_ENV:-production}
PORT=${PORT:-3000}
USE_SSM=false
STAGE=${STAGE:-production}

# Validation: require core DB fields
missing=()
for k in DB_HOST DB_USER DB_PASSWORD DB_NAME; do
	if [ -z "${!k:-}" ]; then missing+=("$k"); fi
done
if [ ${#missing[@]} -ne 0 ]; then
	log "ERROR: Missing required variables: ${missing[*]}"
	log "Provide them via GitHub Secrets exposed to the SSH session (e.g., PROD_DB_HOST/USER/PASSWORD/NAME)."
	exit 1
fi

# Warn on weak/missing secrets in production
if [ "$APP_ENV" = "production" ]; then
	if [ -z "$JWT_SECRET" ] || [ ${#JWT_SECRET} -lt 16 ]; then
		log "WARN: JWT_SECRET missing/weak; set a strong JWT_SECRET in GitHub Secrets."
	fi
fi

TMP_FILE=.env.new
{
	echo "# Auto-generated by fallback-write-env.sh on $(date -u +%Y-%m-%dT%H:%M:%SZ)"
	echo "APP_ENV=$APP_ENV"
	echo "PORT=$PORT"
	echo "STAGE=$STAGE"
	echo "USE_SSM=$USE_SSM"
	echo "AWS_REGION=$AWS_REGION"

	echo "DB_HOST=$DB_HOST"
	echo "DB_PORT=$DB_PORT"
	echo "DB_USER=$DB_USER"
	echo "DB_PASSWORD=$DB_PASSWORD"
	echo "DB_NAME=$DB_NAME"

	echo "REDIS_HOST=$REDIS_HOST"
	echo "REDIS_PORT=$REDIS_PORT"
	echo "REDIS_PASSWORD=$REDIS_PASSWORD"

	[ -n "$JWT_SECRET" ] && echo "JWT_SECRET=$JWT_SECRET"
	echo "JWT_EXPIRES_IN=$JWT_EXPIRES_IN"

	[ -n "$AWS_ACCESS_KEY_ID" ] && echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID"
	[ -n "$AWS_SECRET_ACCESS_KEY" ] && echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY"
	[ -n "$S3_BUCKET_NAME" ] && echo "S3_BUCKET_NAME=$S3_BUCKET_NAME"

		# LINE (optional)
		[ -n "$LINE_CHANNEL_SECRET" ] && echo "LINE_CHANNEL_SECRET=$LINE_CHANNEL_SECRET"
		[ -n "$LINE_CHANNEL_ACCESS_TOKEN" ] && echo "LINE_CHANNEL_ACCESS_TOKEN=$LINE_CHANNEL_ACCESS_TOKEN"

	# Logging defaults (safe)
	echo "LOG_LEVEL=${LOG_LEVEL:-info}"
	echo "LOG_FILE=${LOG_FILE:-logs/app.log}"
	echo "LOG_ARCHIVE_DAYS=${LOG_ARCHIVE_DAYS:-7d}"
	echo "LOG_CACHE_TTL=${LOG_CACHE_TTL:-24h}"

	# File upload defaults
	echo "MAX_FILE_SIZE=${MAX_FILE_SIZE:-10485760}"
	echo "ALLOWED_EXTENSIONS=${ALLOWED_EXTENSIONS:-jpg,jpeg,png,webp,gif}"

	# phpMyAdmin convenience
	[ -n "$PMA_HOST" ] && echo "PMA_HOST=$PMA_HOST"
	[ -n "$PMA_USER" ] && echo "PMA_USER=$PMA_USER"
	[ -n "$PMA_PASSWORD" ] && echo "PMA_PASSWORD=$PMA_PASSWORD"

	# Feature toggles
	echo "USE_REDIS_NOTIFICATIONS=${USE_REDIS_NOTIFICATIONS:-true}"
	echo "SKIP_MIGRATE=${SKIP_MIGRATE:-true}"
	echo "PRUNE_COLUMNS=${PRUNE_COLUMNS:-false}"
} > "$TMP_FILE"

mv "$TMP_FILE" .env
log "Written .env ($APP_ENV) with DB host=$DB_HOST name=$DB_NAME stage=$STAGE"
exit 0

